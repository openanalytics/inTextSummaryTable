---
title: "Introduction to the `inTextSummaryTable` package"
author: "Laure Cougnaud"
date: "`r format(Sys.Date(), '%B %d, %Y')`"
output: glpgStyle::html_report
vignette: >
  %\VignetteIndexEntry{Introduction to the inTextSummaryTable package}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

# Introduction

```{r options, echo = FALSE}
	
	library(knitr)
	opts_chunk$set(
		echo = TRUE, results = 'markup', warning = FALSE, 
		# stop document execution if error (not the default)
		error = FALSE, 
		message = FALSE, cache = FALSE,
		fig.width = 8, fig.height = 7,
		fig.path = "./figures_vignette/",
		fig.align = 'center')
	options(width = 170)
	# instead of warn = 0 by default
	# include warnings when they occur in the document
	options(warn = 1)
	
```

The package `inTextSummaryTable` contains functionalities to **create
complex table of summary statistics or counts of variables of interest**.

This table can be formatted to static **in-text table** for a **Clinical Study Report**, a
**topline presentation** or an **interactive table**, 
e.g. to be used inside the **medical monitoring report**.

These tables can be included into a `rmarkdown` document, to be
converted into `html`, `docx` and `pptx`.
Each table can be separately exported into a `text`, `docx` or `html `document.

```{r loadPackages}

	library(inTextSummaryTable)
	library(pander)
	library(tools)# toTitleCase

```

## Data format

The input data for the creation of summary table should be a **data.frame**,
usually loaded from a _SAS_ data file (`sas7bdat` format).
The label of the variables stored in the `SAS` datasets is also used
for the title/captions. 

Note that the `loadDataADaMSDTM` function of the `glpgUtilityFct` package 
can be used to import your study-specific dataset(s) of interest into R.

For this vignette, ADaM datasets from the _Pelican_ study,
 included in the `glpgpUtilityFct` package are used.

```{r loadData}	
	
	library(glpgUtilityFct)

	# load example data
	data(ADaMDataPelican)
	data(labelVarsADaMPelican)
	
	dataAll <- ADaMDataPelican
	labelVars <- labelVarsADaMPelican
	
	# dataAll contains a list
	class(dataAll)
	# ... of ADaM datasets
	names(dataAll)
	# access a specific dataset
	head(dataAll$ADSL, 1)
	
	# check label of a subset of the variable(s)
	head(labelVars)
	# or for a specific variable:
	labelVars["USUBJID"]
	# or:
	getLabelVar(var = "USUBJID", labelVars = labelVars)

```

# Table components

This section explains how to build your in-text table.

The **`getSummaryStatisticsTable`** creates an
in-text table of summary statistics for variable(s) of interest.

The _Demographic_ data (`ADSL` dataset) is used as example for the summary
statistics table.

```{r data-SL}

	dataSL <- dataAll$ADSL

```

## Variable(s) to summarize

Variable(s) to summarize in the table are specified
via the **`var` parameter**.

Different set of
statistics are reported depending on the type of variable:
[Categorical variable] or [Continuous variable].

See the documentation in section _Base statistics_ for more details 
on the statistics included by default for each type, via:
```{r eval = FALSE}
? `inTextSummaryTable-stats` 
```

### Categorical variable

For a **discrete/categorical variable**, the in-text table can display the **counts/percentages
of the number of subjects or records for each category** of the variable.

#### Counts of the entire dataset

If **no variable is specified** (via the `var` parameter), the counts
are displayed for the **entire dataset**.

```{r count-simple}

	getSummaryStatisticsTable(data = dataSL)

```

Please note that this is equivalent of setting (`var = 'all'`).

#### Counts of variable categories

If a **variable is specified** (via the `var` parameter), the 
counts are displayed **for each category**.

```{r count-categories}

	getSummaryStatisticsTable(data = dataSL, var = "SEX")

```

#### Sort categories

The categories of the variable are sorted alphabetically by default. To sort the categories in a specific order, the variable should be formatted as **`factor`**, whose ordered categories are included in its **`levels`**.

```{r count-categories-order}

	# specify manually the order of the categories
	dataSL$SEX <- factor(dataSL$SEX, levels = c("M", "F"))
	getSummaryStatisticsTable(data = dataSL, var = "SEX")
	
	# order categories based on a numeric variable
	dataSL$SEX <- reorder(dataSL$SEX, dataSL$SEXN)
	getSummaryStatisticsTable(data = dataSL, var = "SEX")
	
```

#### Inclusion of categories not available in the data

By default, the table only includes the categories present in the input data,
to ensure a compact table for CSR export.

```{r count-categories-empty-1}

	dataSLExample <- dataSL
	
	# 'SEX' formatted as character with only male
	dataSLExample$SEX <- "M" # only male
	getSummaryStatisticsTable(data = dataSLExample, var = "SEX")
	
```	

If extra categories should be represented in the table, the categorical 
variable should be **formatted as a factor**, whose **levels contain
all categories** to be displayed in the table.

Furthermore, the parameter: `varInclude0` should be set to `TRUE` 
or to the specific variable (in case multiple variables are specified)
to indicate that categories with 0 counts should be included.

```{r count-categories-empty-2}

	dataSLExample <- dataSL
	
	# 'SEX' formatted as character with only male
	dataSLExample$SEX <- "M" # only male
	getSummaryStatisticsTable(data = dataSLExample, var = "SEX")
	
	# 'SEX' formatted as factor, to include also female in the table
	# (even if not available in the data)
	dataSLExample$SEX <- factor("M", levels = c("F", "M"))
	getSummaryStatisticsTable(data = dataSLExample, var = "SEX", varInclude0 = TRUE)
	# or:
 	getSummaryStatisticsTable(data = dataSLExample, var = "SEX", varInclude0 = "SEX")

```


#### Count table for 'flag'-variables

A specific type of categorical variable is a **flag variable**,
which indicates if a record fulfillss a specific criteria.

Such variable typically includes in the data: 

* 'Y' if the criteria is fulfilled for the specific record
* 'N' if the criteria is not fulfilled for the specific record
* '' if the criteria is missing for this record

The name of such variable typically ends with **'FL'** in CDISC-compliant
_ADaM_ or _SDTM_ dataset.

For example, the subject-level dataset contains the following flag variables:

```{r flag-variables}
labelVars[grep("FL$", colnames(dataSL), value = TRUE)]
# does the subject belong to the full analysis set?
dataSL$FASFL
```

If this variable is specified in `var`, the counts for each category is reported:

```{r count-flag-var}
getSummaryStatisticsTable(
	data = dataSL,
	var = "FASFL"
)
```

However, the interest is often to only reports the counts 
for the records fulfilling the criteria (records with 'Y').
This is the case if the variable is specified via the `varFlag` parameter too.

```{r count-flag-varFlag}

	getSummaryStatisticsTable(
		data = dataSL,
		var = "FASFL",
		varFlag = "FASFL"
	)

```

#### Inclusion of total across categories

To include the total counts across categories,
the `varTotalInclude` parameter should be set to `TRUE`
(or to the specific variable).

```{r count-varTotalInclude}

	getSummaryStatisticsTable(
		data = dataSL, 
		var = "SEX", 
		varTotalInclude = TRUE
	)

```

### Continuous variable

For a **continuous variable**, the in-text table displays
**standard distribution statistics** of the variable.
  
Please note that **missing records for the variable are filtered**, so 
the **count statistics** (number of subjects, records, percentage) are
based **only on the non missing records**.
  
For a continuous variable, the presence of different values for the same subject 
(and across row/column variables) are checked and an appropriate error message
is returned if multiple different values are available.

```{r numeric}

	getSummaryStatisticsTable(data = dataSL, var = "AGE")

```

### Mixed table

The table can contain a mix of categorical and continuous variables.

```{r mixedTable}

	getSummaryStatisticsTable(
		data = dataSL, 
		var = c("AGE", "HEIGHT", "WEIGHTBL", "BMIBL", "RACE", "SEX")
	)

```

## Statistics of interest

Statistics of interest and their format are specified
via the **`stats` parameter**.

If an unique statistic expression is specified, the 'Statistic' column doesn't appear 
in the table. In case multiple statistics are specified, these are included as separated row.

### Standard statistic set

A standard set of statistics is specified via specific tags to be
passed to the `stats` function.

The list of available statistics is mentioned in the section 
_Formatted statistics_ in:
```{r eval = FALSE}
? `inTextSummaryTable-stats` 
```

Please see below examples of commonly used statistics:

```{r stats}

	## count table:

	# count: n, '%' and m
	getSummaryStatisticsTable(
		data = dataSL,
		var = "SEX",
		stats = "count"
	)

	# n (%)
	getSummaryStatisticsTable(
		data = dataSL,
		var = "SEX",
		stats = "n (%)"
	)
	
	# n/N (%)
	getSummaryStatisticsTable(
		data = dataSL,
		var = "SEX",
		stats = "n/N (%)"
	)
	
	## continuous variable
	
	# all summary stats
	getSummaryStatisticsTable(
		data = dataSL,
		var = "AGE",
		stats = "summary"
	)
	
	# median (range)
	getSummaryStatisticsTable(
		data = dataSL,
		var = "AGE",
		stats = "median (range)"
	)
	
	# median and (range) in a different line:
	getSummaryStatisticsTable(
		data = dataSL,
		var = "AGE",
		stats = "median\n(range)"
	)
	
	# mean (se)
	getSummaryStatisticsTable(
		data = dataSL,
		var = "AGE",
		stats = "mean (se)"
	)

```

### Custom statistics formatting (Advanced)

To change the formatting of the statistics,
the `stats` parameter should contain a language
object (e.g. `expression` or `call`)
of the default base set of statistics.

See the documentation in section _Base statistics_ for more details 
on the base statistics included by default, via:
```{r eval = FALSE}
? `inTextSummaryTable-stats` 
```

For example, the following count table is restricted to the number of subjects per categories:

```{r stats-N}

	getSummaryStatisticsTable(
		data = dataSL,
		var = c("RACE", "SEX"),
		stats = list(N = expression(statN))
	)

```

The summary statistics table is restricted to the median and range:

```{r stats-meanSE}

	getSummaryStatisticsTable(
		data = dataSL,
		var = c("AGE", "HEIGHT", "WEIGHTBL", "BMIBL"),
		varGeneralLab = "Parameter", statsGeneralLab = "",
		colVar = "ACTARM",
		stats = list(
			`median` = expression(statMedian),
			`(min, max)` = expression(paste0("(", statMin, ",", statMax, ")"))
		)
	)

```

Note that the [Standard statistics set] is formatted internally via 
the `getStatsData` (and `getStats`) functions, which creates consistently
a list of `language` objects.

```{r getStatsData}
# this count table:
getSummaryStatisticsTable(
	data = dataSL,
	var = "SEX",
	stats = "count"
)
# ... is equivalent to:
getSummaryStatisticsTable(
	data = dataSL,
	var = "SEX",
	stats = getStatsData(type = "count")
)

# this summary table...
getSummaryStatisticsTable(
	data = dataSL,
	var = "AGE",
	stats = "mean (se)"
)
# ... is equivalent to:
getSummaryStatisticsTable(
	data = dataSL,
	var = "AGE",
	stats = getStatsData(type = "mean (se)", var = "AGE", data = dataSL)[["AGE"]]
)
```

### Statistics by variable/group

The statistics can also be provided for each variable separately,
if `stats` is named by variable:

```{r statExtra-EachVariable}
		
	getSummaryStatisticsTable(
		data = dataSL, 
		var = c("AGE", "RACE"),
		stats = list(
			AGE = getStats("median (range)"),
			RACE = getStats("n (%)")
		)
	)

```

### Extra statistics

Extra statistics (not available in the default set of statistics) should 
be specified via the `statsExtra` parameter.

A set of extra utility functions to compute common extra statistics are 
also available in the package:

* coefficient of variation with the `cv` function
* geometric mean with the `geomMean` function
* geometric standard deviation with the `geomSD` function
* geometric coefficient of variation with the `geomCV` function

```{r statsUtilityFct}

	getSummaryStatisticsTable(
		data = dataSL,
		var = "HEIGHT",
		# specify extra stats to compute
		statsExtra = list(
			statCV = cv,
			statGeomMean = geomMean,
			statGeomSD = geomSD,
			statsGeomCV = geomCV
		)
	)

```

Full customized statistics can also be provided.
For example, if you would like to specify your own formula
for the coefficient of variation:

```{r statsExtra}

	# include the coefficient of variation via the 'statsExtra' parameter
	getSummaryStatisticsTable(
		data = dataSL,
		var = "HEIGHT",
		statsExtra = list(statCVPerc = function(x) sd(x)/mean(x)*100)
	)

```

These statistics are then available for customization via the `stats` parameter.

```{r statsExtra-stats}

	# format the statistics with the 'stats' parameter
	getSummaryStatisticsTable(
		data = dataSL,
		var = "HEIGHT",
		statsExtra = list(statCVPerc = function(x) sd(x)/mean(x)*100),
		stats = list(Mean = expression(statMean), 'CV%' = expression(statCVPerc))
	)

```

### Number of decimals

By default, the number of decimals is based on the rules 
specified in the _Mock Standard SAP **Phase 2/3**_ (version 1.0)

The detailed rules are available in the section _Statistics formatting_ in:
```{r eval = FALSE}
? `inTextSummaryTable-stats` 
```

To specify fixed amounts of digits for the statistics to be displayed in the table, 
the statistics are formatted in the `stats` parameter.

#### Default number of decimals

##### Categorical variable

According to the Mock SAP, the counts of number of subjects is reported
without decimals.
The number of decimals for the percentages
is specified below:

```{r nDecimals-catVar-SAP-phase23, echo = FALSE, fig.cap = "Standard Layout for Frequency Tabulations of Categorical Variables<br>(_GLPGS_Mock Standards_v1.0_FINAL.docx_ document, from 5/02/2020)"}
include_graphics("./images/nDecimals_catVar_SAP_phase23.png")
```

By default, the counts for a categorical variables are formatted as specified above:

* the number of subjects is displayed with 0 digits (`nDecN` is set to 0)
* the frequency percentage is implemented in the `formatPercentage` function

```{r getStats-count}

	# Internal rule for the number of decimals for the percentage
	formatPercentage(c(NA, 0, 100, 99.95, 0.012, 34.768))
	
	# Used by default in the 'getStats' function
	getStats(type = "count")

```

##### Continuous variable {#numberDecimalsContinuousVariable}

The number of decimals for individual values is based on the Mock SAP (see tables below)
unless the number of digits in the database is lower. In this case, the resolution of the specified values is used.

```{r nDecimals-numVar-SAP-phase23, echo = FALSE, fig.cap = "Standard Layout for Descriptive Statistics of Continuous Variables<br>(_GLPGS_Mock Standards_v1.0_FINAL.docx_ document, from 5/02/2020)"}
include_graphics("./images/nDecimals_numVar_SAP_phase23.png")
```

In the package: 'Very small values' are considered values below 1.

When specifying the default set of available statistics with the `getStats` function,
and **only if the variable is specified** (`x` parameter),
the number of decimals for a continuous variable is determined by:

1. Extracting the number of decimals for individual values based on:
    + **pre-defined rules** based on the number of decimals of the individual values (`getNDecimalsRule` function)
    + the number of decimals **available in the input data** via the `getNDecimalsData` function
    + taking the **minimum of these two criterias** (`getNDecimals` function), 
    such as the number of decimals according
    the rule won't be higher that the actual number of decimals available in the data
2. Taking the **maximum number of decimals** across all individual values via the `getMaxNDecimals` function, 
which is used as 'base' number of decimals considered for the summary statistics
3. The actual number of decimals for each statistic is extracted (based on the Mock TLFs) by adding
to the 'base' number of decimals:
    + **0 extra decimal for the minimum, maximum**
    + **1 extra decimal for the mean, median, sd**
    + **2 extra decimals for SE**

Please note that if a different framework than implemented in steps 1 and 2
should be used for the extraction of the number of decimals for a specific variable,
the number of decimals of interest can be fixed via the `nDecCont` parameter.

```{r getMaxNDecimals}

	# %FEV1 at baseline
	print(dataSL$PFEVBL)
	
	## Extract the number of decimals for each value:
	
	# based on pre-defined rule, this metric should be displayed with 1 decimal:
	getNDecimalsRule(x = dataSL$PFEVBL)
	
	# but available in the data only with 0 decimals
	getNDecimalsData(x = dataSL$PFEVBL)
	
	# The minimum of the #decimals based on the data and pre-defined rule is:
	getNDecimals(x = dataSL$PFEVBL)
	
	## Take the maximum number of decimals 
	getMaxNDecimals(x = dataSL$PFEVBL)
	
	## Custom set of statistics are extracted when x is specified:
	getStats(x = dataSL$PFEVBL)
	
	# To fix the number of decimals:
	getStats(type = "summary", nDecCont = 1)
	
	## Create summary statistics table
	getSummaryStatisticsTable(
		data = dataSL,
		var = c("AGE", "PFEVBL"),
		stats = list(
			AGE = getStats(type = "median (range)", x = dataSL$AGE),
			PFEVBL = getStats(type = "median (range)", x = dataSL$PFEVBL)
		)
	)

```

Notes: by default the `round` function in R rounds the number to the even number in case of 0.5. 
The `roundHalfUpTextFormat` function rounds to the closest digit.

#### Custom `stats` function (Advanced)

A  custom function can be created to create custom statistics with fixed number of digits.

For example, the AGE is displayed with 1 digit and the height with two digits:

```{r stats-digits}

	getSummaryStatisticsTable(
		data = dataSL,
		var = c("AGE", "HEIGHT"),
		stats = list(
			AGE = list(Median = expression(roundHalfUpTextFormat(statMedian, 1))),
			HEIGHT = list(Median = expression(roundHalfUpTextFormat(statMedian, 2)))
		)
	)

```

To create the `stats` parameter for a specific number of digits,
a custom function can be created:

```{r stats-digits-complex}

	# wrapper function to include median with specific number of digits
	# and min/max with specified number of digits - 1
	statsDMNum <- function(digitsMin)
		list('Median (range)' = 
			bquote(paste0(
				roundHalfUpTextFormat(statMedian, .(digitsMin+1)), 
				" (", roundHalfUpTextFormat(statMin, .(digitsMin)), ",", 
				roundHalfUpTextFormat(statMax, .(digitsMin)),
				")"
			))
	)

	getSummaryStatisticsTable(
		data = dataSL,
		var = c("AGE", "HEIGHT", "WEIGHTBL", "BMIBL", "RACE", "SEX"),
		stats = list(
			AGE = statsDMNum(0),
			HEIGHT = statsDMNum(1),
			WEIGHTBL = statsDMNum(1),
			BMIBL = statsDMNum(1),
			RACE = getStats("n (%)"),
			SEX = getStats("n (%)")
		)
	)

```

### Statistics layout

The layout of the statistics is specified via the `statsLayout` parameter.  

By default, the statistics are included in rows within each
variable.

```{r statsLayoutRow}

	# statsLayout = 'row'
	getSummaryStatisticsTable(
		data = dataSL,
		var = c("AGE", "HEIGHT"),
		stats = list(Mean = expression(statMean), 'SE' = expression(statSE))
	)
	
```

The statistics can also be included in columns.

```{r statsLayoutCol}

	getSummaryStatisticsTable(
		data = dataSL,
		var = c("AGE", "HEIGHT"),
		stats = list(Mean = expression(statMean), 'SE' = expression(statSE)),
		statsLayout = "col"
	)

```

The statistics can also be specified in different rows, but in a separated column.

```{r summaryTable-PP-medianMinMax-statsLayoutRowVarInSepCol}

	getSummaryStatisticsTable(
		data = dataSL,
		var = c("AGE", "HEIGHT"),
		stats = list(Mean = expression(statMean), 'SE' = expression(statSE)),
		statsLayout = "rowInSepCol"
	)

```

By default, if only one statistic is available in the table,
the name of the statistic is not included in the rows/columns,
as the statistic is generally described in this case in the title
of the table.

```{r summaryTable-statsLayout-onlyOneStat}

	getSummaryStatisticsTable(
		data = dataSL,
		var = c("AGE", "HEIGHT"),
		stats = list(Mean = expression(statMean))
	)

```

To include even in this case the name of the statistic, the 
parameter `statsLabInclude` should be set to `TRUE`.

```{r summaryTable-statsLayout-onlyOneStat-statsLabInclude}

	getSummaryStatisticsTable(
		data = dataSL,
		var = c("AGE", "HEIGHT"),
		stats = list(Mean = expression(statMean)),
		statsLabInclude = TRUE
	)

```

## Table layout

The general table layout is driven by the specification
of variables to be displayed in rows (in the vertical direction) or
in columns (in the horizontal direction).

If no variables are specified in `var`, counts across row/column variable
are displayed.

The adverse events dataset is used for demonstration.

```{r countTable-AE-data}
				
	dataAE <-  subset(dataAll$ADAE, FASFL == "Y" & TRTEMFL == "Y")
	dataAEInterest <- subset(dataAE, AESOC %in% c("Infections and infestations", "General disorders and administration site conditions", "Ear and labyrinth disorders"))

	# ensure that order of elements is the one specified in 
	# the corresponding numeric variable
	library(glpgUtilityFct)
	dataAEInterest <- convertVarToFactor(
		data = dataAEInterest, 
		var = c("TRTP", "AESEV"),
		varNum = c("TRTPN", "AESEVN")
	)

```

### Row and column variables

Specific grouping variable(s) for the columns can be specified via the
**`colVar`** parameter and for the rows via the **`rowVar`** parameter.

If multiple category variables are specified, they should be specified in
hierarchical order.

```{r rowVarColVar}

	# unique row variable
	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = "AEDECOD",
		stats = getStats("n (%)"),
		labelVars = labelVars
	)
	
	# multiple nested row variables
	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		stats = getStats("n (%)"),
		labelVars = labelVars
	)
	
	# unique column variable
	getSummaryStatisticsTable(
		data = dataAEInterest,
		colVar = "TRTP",
		stats = getStats("n (%)"),
		labelVars = labelVars
	)
	
	# combination of rows and columns
	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTP",
		stats = getStats("n (%)"),
		labelVars = labelVars,
		colHeaderTotalInclude = FALSE
	)

```

### Row variable

By default (when `outputType` is set to: 'flextable'), if multiple row variables are specified, 
they are considered nested
and displayed in the first column of the final table.
Each sub-category is indicated with a specific indent (customizable with
`rowVarPadBase`).

#### Variable in separated column

**Row variables** that should be included as a **separated column** 
should be specified via the
`rowVarInSepCol` parameter.

```{r rowVarInSepCol}

	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD", "AESEV"),
		rowVarInSepCol = "AESEV",
		colVar = "TRTP",
		stats = getStats("n (%)"),
		labelVars = labelVars
	)
	
```

#### Row ordering

The **categories in the row variables can be ordered** based on the
**`rowOrder`** variable. 

This variable is either:

* a string with the name of an implemented method to order the rows, among:
     + `alphabetical`: categories are ordered **alphabetically**
     + `auto`: categories are ordered based on the **levels** if the input variable is a factor, 
     alphabetically otherwise
     + `total`: categories are ordered based on the 'total' column (see section \@ref(colTotal)) 
     (if the total column is not included in the table)
* a custom ordering function to apply in the data to order the rows

##### Common order for all row variables

```{r rowOrder-common}

	# 'auto':

	# set order of SOC to reverse alphabetical order
	dataAEInterest$AESOC <- factor(
		dataAEInterest$AESOC, 
		levels = rev(sort(unique(dataAEInterest$AESOC)))
	)
	# AEDECOD is not a factor -> sort alphabetically by default
	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		rowVarLab = labelVars[c("AEDECOD")],
		rowVarTotalInclude = c("AESOC", "AEDECOD"),
		colVar = "TRTP", colTotalInclude = TRUE,
		stats = getStats("n (%)"),
		labelVars = labelVars
	)
	
	# total counts
	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		rowVarLab = labelVars[c("AEDECOD")],
		rowVarTotalInclude = c("AESOC", "AEDECOD"),
		colVar = "TRTP", colTotalInclude = TRUE, colTotalLab = "Number of subjects",
		rowOrder = "total",
		stats = getStats("n (%)"),
		labelVars = labelVars
	)
	# same order even if the 'total' column is not specified
	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		rowVarLab = labelVars[c("AEDECOD")],
		rowVarTotalInclude = c("AESOC", "AEDECOD"),
		colVar = "TRTP", 
		rowOrder = "total", 
		stats = getStats("n (%)"),
		labelVars = labelVars
	)

```

##### Different orders for each row variable

In case the order should be different for each row variable, a named list is
provided for the `rowVar` parameter.

```{r rowOrder-specific}

	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		rowVarLab = labelVars[c("AEDECOD")],
		rowVarTotalInclude = c("AESOC", "AEDECOD"),
		colVar = "TRTP", #colTotalInclude = TRUE,
		rowOrder = c(AESOC = "alphabetical", AEDECOD = "total"),
		stats = getStats("n (%)"),
		labelVars = labelVars
	)

```

##### Row order based on the total of a column category

If the row categories should be **ordered by total counts for a specific
category of the column variable(s)**, a function **`rowOrderTotalFilterFct`** is
specified.

The adverse events are sorted based on the incidence in the treated group.

```{r rowOrder-rowOrderTotalFilterFct}

	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		rowVarLab = labelVars[c("AEDECOD")],
		rowVarTotalInclude = c("AESOC", "AEDECOD"),
		colVar = "TRTP", colTotalInclude = TRUE,
		rowOrder = "total",
		stats = getStats("n (%)"),
		labelVars = labelVars,
		# consider only the counts of the treated patients to order the rows
		rowOrderTotalFilterFct = function(x) subset(x, TRTP == "treatmentX")
	)

```

##### Row order based on a custom specified function

If the method to order the rows is more complex, the `rowOrder` parameter specifies
a function taking the summary table as input and returning the order
levels of the elements in the row variable.

For example, the adverse event table is sorted based on the counts of patient
presenting this event across all treatment classes, and in case of ties based on 
the counts of treated-patients presenting this event.

```{r rowOrder-function-example1}

	library(plyr)
	getSummaryStatisticsTable(
		data = dataAEInterest,
		type = "count",
		rowVar = "AEHLT",
		rowOrder = function(x){
			x <- subset(x, !isTotal)
			totalAcrossTreatments <- subset(x, TRTP == "Total")
			# counts across treated patients
			totalForTreatmentOnly <- subset(x, TRTP == "treatmentX")
			dataCounts <- merge(totalAcrossTreatments, totalForTreatmentOnly, by = "AEHLT", suffixes = c(".all", ".treat"))
			# sort first based on overall count, then counts of treated patients
			dataCounts[with(dataCounts, order(`statN.all`, `statN.treat`, decreasing = TRUE)), "AEHLT"]
		},
		colVar = "TRTP", colTotalInclude = TRUE,
		labelVars = labelVars,
		title = "Table: Adverse Events ordered based on total counts",
		stats = list(expression(paste0(statN, " (", round(statPercN, 1), ")"))),
		footer = "Statistics: n (%)"
	)

```

The adverse event table is now ordered based on the counts in the placebo, then
treated-patients column, for the organ class and the adverse event term separately.

```{r rowOrder-function-example2}

	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		rowVarLab = labelVars[c("AEDECOD")],
		rowVarTotalInclude = c("AESOC", "AEDECOD"),
		colVar = "TRTP", colTotalInclude = TRUE,
		rowOrder = list(
			AESOC = function(table){
				# records with total for each AESOC
				nAESOCPlacebo <- subset(table, !isTotal & grepl("placebo", TRTP) & AEDECOD == "Total")
				nAESOCTreat <- subset(table, !isTotal & grepl("75 mg", TRTP) & AEDECOD == "Total")
				nAESOCDf <- merge(nAESOCPlacebo, nAESOCTreat, by = "AESOC", suffixes = c(".placebo", ".treatment"))
				nAESOCDf[with(nAESOCDf, order(`statN.placebo`, `statN.treatment`, decreasing = TRUE)), "AESOC"]
			},
			AEDECOD = function(table){
				# records with counts for each AEDECOD
				nAEDECODPlacebo <- subset(table, !isTotal & grepl("placebo", TRTP) & AEDECOD != "Total")
				nAEDECODTreat <- subset(table, !isTotal & grepl("75 mg", TRTP) & AEDECOD != "Total")
				nAEDECODDf <- merge(nAEDECODPlacebo, nAEDECODTreat, by = "AEDECOD", suffixes = c(".placebo", ".treatment"))
				nAEDECODDf[with(nAEDECODDf, order(`statN.placebo`, `statN.treatment`, decreasing = TRUE)), "AEDECOD"]
			}
		),
		stats = getStats("n (%)"),
		labelVars = labelVars
	)

```

#### Row variable labels

##### Based on dataset

The **labels used for the variables parameter** (row variables) **are
automatically extracted from the labels** contained in the _SAS_ dataset, by
specifying the `labelVars` parameter.

```{r summaryTable-PP-rowVarWithLabel-labelVars}

	# combination of rows and columns
	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTP",
		stats = getStats("n (%)"),
		labelVars = labelVars
	)
	
```

##### Custom

The label can also be specified directly via the `rowVarLab` parameter,
for each variable in `rowVar`.

If an unique row label should be used (even if multiple row variables are
specified), `rowVarLab` is set to this unique label.

```{r summaryTable-PP-rowVarWithLabel-rowVarLab}

	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTP",
		stats = getStats("n (%)"),
		rowVarLab = c(
			'AESOC' = "TEAE by SOC and Preferred Term\nn (%)"
		),
		labelVars = labelVars
	)
	
```

#### Inclusion of row/column categories not available in the data

As for the variable to summarize, to include categories in the 
row or column variables not
available in the data, these variables should be formatted
as a factor with categories specified in its levels.

Furthermore, the parameters `rowInclude0` and `colInclude0` should be set to TRUE to 
include counts for empty categories within the row/column. 

```{r countTable-emptyVars}

	## only consider White blood cell adverse events
	dataAESubset <- subset(dataAE, AEHLT == "Viral infections NEC")
	
	## create dummy categories for:
	# treatment
	dataAESubset$TRTP <- with(dataAESubset, 
		factor(TRTP, levels = c(unique(as.character(TRTP)), "Treatment B"))
	)
	# low-level term category
	dataAESubset$AELLT <- with(dataAESubset, 
		factor(AELLT, levels = c(unique(as.character(AELLT)), "Lymphocyte percentage increased"))
	)
	
	# create summary statistics table
	getSummaryStatisticsTable(
		data = dataAESubset,
		type = "count",
		rowVar = c("AEHLT", "AELLT"),
		rowInclude0 = TRUE, colInclude0 = TRUE,
		colVar = "TRTP",
		labelVars = labelVars,
		title = "Table: Adverse Events: white blood cell analyses",
		stats = getStats("n (%)"),
		footer = "Statistics: n (%)"
	)

```


### Variable(s) to summarize

#### Default

The **variable(s) used for the summary statistics** 
(`var`) are included **by default in rows**.

```{r summaryTable-layout-var}

	dataPFEV1 <- subset(dataAll$ADRE, FASFL == "Y" & PARAMCD == "FEV1PP" & AN01FL == "Y")
	dataPFEV1 <- convertVarToFactor(
		data = dataPFEV1, 
		var = c("TRTP", "AVISIT"),
		varNum = c("TRTPN", "AVISITN")
	)
	getSummaryStatisticsTable(
		data = dataPFEV1,
		var = c("AVAL", "CHG", "PCHG"),
		colVar = c("TRTA"),
		rowVar = "AVISIT",
		labelVars = labelVars,
		stats = getStats("summary-default")
	)

```

#### Summary variable in columns

In case multiple variables are to be summarized, the different variables can be included in 
different columns by including the specific label: 'variable' in `colVar`.
Beware that such layout only makes sense for variables
with similar types (e.g. all numeric variables).

```{r summaryTable-layout-varInColumn}

	dataPFEV1 <- subset(dataAll$ADRE, FASFL == "Y" & PARAMCD == "FEV1PP" & AN01FL == "Y")
	dataPFEV1 <- convertVarToFactor(
		data = dataPFEV1, 
		var = c("TRTP", "AVISIT"),
		varNum = c("TRTPN", "AVISITN")
	)
	getSummaryStatisticsTable(
		data = dataPFEV1,
		var = c("AVAL", "CHG", "PCHG"),
		colVar = c("variable", "TRTA"),
		rowVar = "AVISIT",
		labelVars = labelVars,
		stats = getStats("summary-default")
	)

```

#### Inclusion of summary variables in case one variable is specified

By default, the variable label is not included if only one summary
statistic variable is specified.

```{r summaryTable-layout-var-oneLabel-default}
		
	getSummaryStatisticsTable(data = dataSL, var = "AGE", colVar = "TRT01P")

```

To include the label in case only one summary statistic variable
is specified, the parameter `varLabInclude` should be set to TRUE.

```{r summaryTable-layout-var-oneLabel-varLabInclude}
		
	getSummaryStatisticsTable(
		data = dataSL, 
		var = "AGE", 
		varLabInclude = TRUE,
		colVar = "TRT01P"
	)

```

### Inclusion of the count per group in case of missing values

It might be of interest to display the counts of all subjects per
row/column variable in association of the summary statistic 
of a variable of interest.

For example it could be of interest to report the total number of subjects
per group, which could differ from the total number of subjects 
for a variable of interest if this variable contain missing values.

```{r summaryTable-layout-var-empty}

	dataAEInterestWC <- ddply(dataAEInterest, c("AEDECOD", "USUBJID", "TRTA"), function(x){
		x[which.max(x$AESEVN), ]
	})
	dataAEInterestWC[1, "AESEV"] <- NA
    getSummaryStatisticsTable(
        data = dataAEInterestWC,
        colVar = "TRTA",
        rowVar = "AEBODSYS",
		stats = getStats("n (%)"),
        var = c("AESEV", "all"),
		labelVars = labelVars
    )

```

## Total

The summary table contains **different types of total**:

* total used for the **percentage computation**
displayed in the table.  
For example: report percentage of subjects with specific adverse event.
* total reported in the **column header**
Typically: total number of subjects for a specific treatment arm.
* **total across rows**, reported in the row header   
For example: to report percentage
of subjects with adverse events in a specific body system 
(across adverse events).
* **total across columns**, reported in a separated column  
For example: to report summary statistics
across all treatments arms.

By default, the totals are extracted based on the input data, but 
separated datasets can be specified for the header,
 percentage computation, row or column total.

### Summary

The different types of total of the summary table are summarized below:

| Type | Inclusion in the table |  Dataset: parameter name | Dataset: default | 
|---|---|---|---| 
| Total in the column header | Yes by default <br/> removed if `colHeaderTotalInclude = FALSE`| `dataTotal` | `data` for table content <br/> `dataTotalCol` for total column| 
| Total for the percentage | Only if percentage requested in `stats` | `dataTotalPerc` | `dataTotal` for table content <br/> `dataTotalCol` for total column <br/> (for 'total' if specified as a list)| 
| Total across rows | Not by default <br/> for specified row variable with `rowVarTotalInclude` | `dataTotalRow`  | `data` for table content <br/> `dataTotalCol` for total column <br/> (for 'total' if specified as a list) | 
| Total across columns | Not by default <br/> only if `colTotalInclude = TRUE` | `dataTotalCol` | `data` |

### Total for the column header

By default, the total reported in the total header is extracted 
from the **available number of subjects** 
in the input `data`.

For example, the total number of patients per treatment arm is extracted from the 
subject-level (`ADSL`) dataset. 

```{r header-total-default}
	
	# by default, total number of subjects extracted from data
	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTA",
		stats = getStats("n (%)"),
		rowVarLab = c(
			'AESOC' = "TEAE by SOC and Preferred Term\nn (%)"
		),
		labelVars = labelVars
	)
	
```

#### Dataset

 If the total should be extracted from a **different dataset**, 
 it should be specified via the **`dataTotal`** variable.
 Please note that by default `dataTotal` is also used for
 the computation of the percentage.

```{r header-total-dataTotal}	
	
	# dataset used to extract the 'Total'
	dataTotalAE <- subset(dataAll$ADSL, TRT01A != "Screen Failure")
	# should contain columns specified in 'colVar'
	dataTotalAE$TRTA <- dataTotalAE$TRT01A 

	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTA",
		stats = getStats("n (%)"),
		rowVarLab = c(
			'AESOC' = "TEAE by SOC and Preferred Term\nn (%)"
		),
		dataTotal = dataTotalAE,
		labelVars = labelVars
	)

```

### Remove total in column header

The total number of subjects in each column is by default included. 
This is not displayed if `colHeaderTotalInclude` is set to FALSE.

```{r header-total-colHeaderTotalInclude}

	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		rowVarTotalInclude = "AEDECOD",
		rowVarTotalInSepRow = "AEDECOD",
		colVar = "TRTA",
		stats = getStats("n (%)"),
		rowVarLab = c(
			'AESOC' = "TEAE by SOC and Preferred Term\nn (%)"
		),
		dataTotal = dataTotalAE,
		labelVars = labelVars,
		colHeaderTotalInclude = FALSE
	)

```

### Percentage

#### Dataset

A different dataset used for the computation of the percentage can be specified
via the **`dataTotalPerc`** parameter.  

```{r dataTotalPerc}

getSummaryStatisticsTable(
	data = dataAEInterest,
	rowVar = c("AESOC", "AEDECOD"),
	colVar = "TRTA",
	stats = getStats("n (%)"),
	rowVarLab = c(
		'AESOC' = "TEAE by SOC and Preferred Term\nn (%)"
	),
	dataTotalPerc = dataTotalAE,
	labelVars = labelVars
)

```

Please note that by default, if `dataTotalPerc` is specified,
but not `dataTotal`, counts
reported in the column header are still extracted from `data`.

#### Variables to compute percentage by

If the total number of subjects differ between the components of the table, 
the extra row/column(s) variable(s) are specified via `colVarTotalPerc`/`rowVarTotalPerc`.

For example, in the table of shift of worst-case laboratory abnormalities: the total number
of subjects for the computation of the percentage are extracted based on the number of subjects 
with available post-dose measurements **per laboratory parameter**.

```{r rowVarTotalPerc}

	dataLB <- subset(dataAll$ADLB, FASFL == "Y" & PARAMCD %in% c("BACT", "ALB"))
	
	# worst-case scenario with abnormalities
	dataLBWC <- subset(dataLB, AVISIT == "Worst-case post-baseline" & SHIFT1 != "")

	# data considered for the total
	dataLBPostBaseline <- subset(dataLB, !AVISIT %in% c("Baseline", "Screening", "Worst-case post-baseline"))
	
	# post-baseline measurements  are not available for all subjects 
	kable(aggregate(USUBJID ~ PARAM + TRTA, data = dataLBPostBaseline, function(x) length(unique(x))))
	
	# by default, the same total number of subjects 
	# per treatment is used across all rows/parameters
	getSummaryStatisticsTable(
		data = dataLBWC,
		colVar = "TRTA", rowVar = "PARAM", var = "SHIFT1",
		stats = getStats("n (%)"),
		emptyValue = 0, rowAutoMerge = FALSE,
		dataTotal = dataLBPostBaseline
	)
	
	# percentage based on total number of subjects with available
	# post-baseline measurements PER parameter:
	getSummaryStatisticsTable(
		data = dataLBWC,
		colVar = "TRTA", rowVar = "PARAM", var = "SHIFT1",
		stats = getStats("n (%)"),
		emptyValue = 0, rowAutoMerge = FALSE,
		# total for column header
		dataTotal = dataLBPostBaseline, 
		dataTotalPerc = dataLBPostBaseline,
		rowVarTotalPerc = "PARAM"
	)
	
```

#### Percentage of the number of records

By default, the percentage is based on the 
number of subjects.  

If the percentage should be computed based on the number of records instead, 
the parameter: `statsPerc`
should be set to `statm` (`statN` by default).

For example, to extract the percentage of laboratory
measurements by reference range and parameter:

```{r statsPerc}
getSummaryStatisticsTable(
	data = dataLBWC,
	colVar = "TRTA", rowVar = "PARAM", var = "SHIFT1",
	stats = getStats("m (%)"), statsPerc = "statm",
	emptyValue = 0, rowAutoMerge = FALSE,
	rowVarTotalPerc = "PARAM",
	# total for column header
	dataTotal = dataLBPostBaseline,
	# total for the percentage
	dataTotalPerc = dataLBPostBaseline
)
```

### Total across columns {#colTotal}

#### Inclusion

The total **across all columns** is included 
if the `colTotalInclude` is set to TRUE.

```{r colTotalInclude}

	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTA",
		colTotalInclude = TRUE, 
		stats = getStats("n (%)"),
		rowVarLab = c(
			'AESOC' = "TEAE by SOC and Preferred Term\nn (%)"
		),
		dataTotal = dataTotalAE,
		labelVars = labelVars
	)

```

By default, the total number of subjects is extracted based on the
input dataset across columns: subjects presenting the 
**same event in multiple column(s) are counted once**
in the column total (e.g. for adverse event table in a context of cross-over experiment).

#### Label

This column is by default labelled 'Total', but this can be customized with the
`colTotalLab` parameter.

```{r colTotalLab}

	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTA",
		colTotalInclude = TRUE, colTotalLab = "All subjects",
		stats = getStats("n (%)"),
		rowVarLab = c(
			'AESOC' = "TEAE by SOC and Preferred Term\nn (%)"
		),
		dataTotal = dataTotalAE,
		labelVars = labelVars
	)

```

#### Dataset

A different dataset for the total column can also be specified via the `dataTotalCol` parameter.

For example, the table is restricted to only the treatment arm,
but both arms are considered in the total column:

```{r dataTotalCol}

	getSummaryStatisticsTable(
		data = subset(dataAEInterest, grepl("75 mg", TRTA)),
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTA",
		colTotalInclude = TRUE, colTotalLab = "Placebo and treatment arm",
		dataTotalCol = dataAEInterest,
		stats = getStats("n (%)"),
		rowVarLab = c(
			'AESOC' = "TEAE by SOC and Preferred Term\nn (%)"
		),
		dataTotal = dataTotalAE,
		labelVars = labelVars
	)

```

### Total across rows

#### Inclusion

If the total should be included across elements of specific `rowVar`
variable(s), this(these) variable(s) should be included in `rowVarTotalInclude`.

```{r rowVarTotalInclude}

	# total reported across AESOC
	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		rowVarTotalInclude = "AESOC", 
		colVar = "TRTA",
		stats = getStats("n (%)"),
		labelVars = labelVars
	)
	
	# total reported across AESOC and across AEDECOD
	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		rowVarTotalInclude = c("AESOC", "AEDECOD"), 
		colVar = "TRTA",
		stats = getStats("n (%)"),
		labelVars = labelVars
	)

```

In case multiple row variables are specified, the total can also be included for each of this variable. In this case, the 
total is by default included in the header of each category of this variable.

#### Label

For the first row variable, the total is included in the first row of the table,
with the label specified in `rowTotalLab`.

```{r rowTotalLab}

	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		rowVarTotalInclude = "AESOC", rowTotalLab = "Any AE", 
		colVar = "TRTA",
		stats = getStats("n (%)"),
		labelVars = labelVars
	)

```

#### Inclusion as separated category

The row total can also be included as a separated category ('Total') in the table, if this
variable is additionally specified in `rowVarTotalInSepRow`.

```{r rowVarTotalInclude-rowVarTotalInSepRow}

	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		rowVarTotalInclude = "AEDECOD",
		rowVarTotalInSepRow = "AEDECOD",
		colVar = "TRTA",
		stats = getStats("n (%)"),
		labelVars = labelVars
	)

```

#### Dataset

A different dataset considered for the row total is specified via the 
`dataTotalRow` parameter.

Different datasets can also be specified for each row variable separately (via a named list).

For example, in the worst-case treatment-emergent adverse events table, the total
per SOC and across SOCs should count the patient once per severity class.

```{r dataTotalRow}

	dataTEAEInterest <- subset(
		dataAll$ADAE, 
		SAFFL == "Y" & TRTEMFL == "Y" &
		AESOC %in% c("Injury, poisoning and procedural complications", "Nervous system disorders")
	)

	# extract worst-case scenario data (only one record if multiple with same severity)
	dataTEAEInterestWC <- ddply(dataTEAEInterest, c("AEDECOD", "USUBJID", "TRTA"), function(x){
		x[which.max(x$AESEVN), ]
	})
	kable(ddply(dataTEAEInterestWC[, c("USUBJID", "TRTA", "AESOC", "AEDECOD", "AESEV", "AESEVN")], "USUBJID"), split.tables = Inf)

	## datasets used for the total: 
	# for total: compute worst-case across SOC and across AE term
	# (otherwise patient counted in multiple categories if present different categories for different AEs)
	dataTotalRow <- list(
		# within SOC (across AEDECOD)
		'AEDECOD' = ddply(dataTEAEInterestWC, c("AESOC", "USUBJID", "TRTA"), function(x){	
			x[which.max(x$AESEVN), ]
		}),
		# across SOC
		'AESOC' = ddply(dataTEAEInterestWC, c("USUBJID", "TRTA"), function(x){	
			x[which.max(x$AESEVN), ]
		})
	)

	getSummaryStatisticsTable(
		data = dataTEAEInterestWC,
		## row variables:
		rowVar = c("AESOC", "AEDECOD", "AESEV"), rowVarInSepCol = "AESEV",
		# include total across SOC and across AEDECOD
		dataTotal = dataTotalAE, # total for column header and denominator
		rowVarTotalInclude = c("AESOC", "AEDECOD"), 
		dataTotalRow = dataTotalRow, # data for total row
		rowVarTotalByVar = "AESEV", # count for each severity category for the total
		rowTotalLab = "Any TEAE", 
		rowVarLab = c(AESOC = "Subjects with, n(%):", AESEV = "Worst-case scenario"),
		# sort per total in the total column
		rowOrder = "total", 
		## column variables
		colVar = "TRTA", 
		stats = getStats("n (%)"),
		emptyValue = "0",
		labelVars = labelVars
	)

```

For example, the patient: '202-4903-03' present a moderate severity for headache, 
and mild severity for the 
chest injury and fall, but is only counted in the once in the table total.



## Labels

If the data is loaded into R with the `read_haven` of the `haven` package,
 or the `loadDataADaMSDTM` function of the `glpgUtilityFct` package, the label
 for each variable is stored in the 'label' attribute of the corresponding
 column.

However, if this label is lost (e.g. if the object is subsetted), 
labels can be specified via the `labelVars` parameter for all variables at once, 
or via specific `[parameter]Lab` parameter, as `rowVarLab`/`colVarLab`/`varLab`
for the row/column/variable to summarize respectively.

## Title and footnote

Title and footnote are specified via the corresponding `title` and `footer` parameters.
The convenient function `toTitleCase` from the `tools` package
is used to set title case for the title of the summary statistics table.

```{r titleAndFooter}

	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTA",
		stats = getStats("n (%)"),
		dataTotal = dataTotalAE,
		labelVars = labelVars,
		title = toTitleCase("MOR106-CL-102: Adverse Events by System Organ Class and Preferred Term (Safety Analysis Set, Part 1)"),
		footer = c(
			"N=number of subjects with data; n=number of subjects with this observation",
			"Denominator for percentage calculations = the total number of subjects per treatment group in the safety population"
		)
	)

```



# Table formatting/export

## Output formats {#outputFormat}

The `outputType` parameter specifies the output format of the summary statistics table.

### Word/PowerPoint

#### General format

To get the table in a format **suitable for _Word_/_PowerPoint_**,
the _outputType_ parameter should be set to **'flextable'** (the default).

```{r outputType-flextable}

	summaryTableFt <- getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTA",
		stats = getStats("n (%)"),
		dataTotal = dataTotalAE,
		labelVars = labelVars,
		title = "Table: Adverse Events by System Organ Class and Preferred Term",
		footer = c(
			"N=number of subjects with data; n=number of subjects with this observation",
			"Denominator for percentage calculations = the total number of subjects per treatment group in the safety population"
		),
		rowVarLab = c('AESOC' = "TEAE by SOC and Preferred Term\nn (%)"),
		outputType = "flextable"
	)
	class(summaryTableFt)
	summaryTableFt

```

This format is available via the [`flextable` R package](https://cran.r-project.org/package=flextable) 
(see `?flextable`).

When printed into the R console, this object is displayed in the browser. 
This object can be inserted within a `rmarkdown` document by printing it 
in the specified document chunk, providing than:

* `flextable` version >= 0.4.7
* for a `docx` document (`output_type`): [pandoc](https://pandoc.org/installing.html) version >= 2.0
(see [`rmarkdown` documentation for Word](https://bookdown.org/yihui/rmarkdown/word-document.html))
* for `pptx` document: [pandoc](https://pandoc.org/installing.html) version >= 2.4 
(see [`rmarkdown` documentation for PowerPoint](https://bookdown.org/yihui/rmarkdown/powerpoint-presentation.html))

A `rmarkdown` chunk can contains only one `flextable` object. 
To include a list of `flextable` in a `rmarkdown` document, 
the function `knitPrintListObjects` of the `glpgUtilityFct` package can be used.

#### Report or presentation

The table can be styled via the `style` parameter.
This parameter affects the fontsize, font family, color of the text and
background, dimensions of the table.

By default, the table is styled for a CSR report.

```{r style-report}

	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTA",
		stats = getStats("n (%)"),
		dataTotal = dataTotalAE,
		labelVars = labelVars,
		title = "Table: Adverse Events by System Organ Class and Preferred Term",
		footer = c(
			"N=number of subjects with data; n=number of subjects with this observation",
			"Denominator for percentage calculations = the total number of subjects per treatment group in the safety population"
		),
		rowVarLab = c('AESOC' = "TEAE by SOC and Preferred Term\nn (%)")
	)

```

The table can also be styled for a presentation.
In this case, the color/style follows _Galapagos_ style guidelines.

```{r style-presentation}

	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTA",
		stats = getStats("n (%)"),
		dataTotal = dataTotalAE,
		labelVars = labelVars,
		title = "Table: Adverse Events by System Organ Class and Preferred Term",
		footer = c(
			"N=number of subjects with data; n=number of subjects with this observation",
			"Denominator for percentage calculations = the total number of subjects per treatment group in the safety population"
		),
		rowVarLab = c('AESOC' = "TEAE by SOC and Preferred Term\nn (%)"),
		style = "presentation"
	)

```

Note: specific parameters can be used to export the table as
landscape (`landscape`), specify custom margins (`margin`), row indent
(`rowVarPadBase`), font size and family (`fontsize` and `font`).

### Interactive table: `DT`

The summary statistics table is exported as an interactive table
by setting the parameter: `outputType` to: 'DT'.
A `datatable` object, created with the [DT](https://CRAN.R-project.org/package=DT) R
package is created.

```{r outputType-DT}

	getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTA",
		stats = getStats("n"),
		dataTotal = dataTotalAE,
		labelVars = labelVars,
		title = "Table: Adverse Events by System Organ Class and Preferred Term",
		footer = c(
			"N=number of subjects with data; n=number of subjects with this observation",
			"Denominator for percentage calculations = the total number of subjects per treatment group in the safety population"
		),
		rowVarLab = c('AESOC' = "TEAE by SOC and Preferred Term\nn (%)"),
		outputType = "DT"
	)

```

Interactivity includes the functionalities to:

* filter the table
* order columns
* export the table (or a subset of this)
* include custom interactivity e.g. the possibility to have expandable rows/columns, 
see patient profiles inclusion in the medical monitoring report

Such table can be included in a _html_ `rmarkdown` report.

### `data.frame`

#### Final table

The supporting data displayed in the final summary table object is output to a R
`data.frame` if `outputType` is set to `data.frame`.

```{r outputType-dataframe}

	summaryTable <- getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTA",
		stats = getStats("n (%)"),
		dataTotal = dataTotalAE,
		labelVars = labelVars,
		title = "Table: Adverse Events by System Organ Class and Preferred Term",
		footer = c(
			"N=number of subjects with data; n=number of subjects with this observation",
			"Denominator for percentage calculations = the total number of subjects per treatment group in the safety population"
		),
		rowVarLab = c('AESOC' = "TEAE by SOC and Preferred Term\nn (%)"),
		style = "presentation",
		outputType = "data.frame"
	)
	pander(summaryTable, split.table = Inf)

```

#### Full table in long format

The table with all the base computed summary statistics, the specified
set of statistics of interest and all row/column variables stored in
a long format is available by using the `outputType` parameter to: 'data.frame-base'.

This format is typically of interest for QC the computed summary statistics
e.g. with TLFs, or to compare the statistics computed between 
batches of the data.

```{r outputType-dataframe-base}

summaryTableAll <- getSummaryStatisticsTable(
	data = dataAEInterest,
	rowVar = c("AESOC", "AEDECOD"),
	colVar = "TRTA",
	stats = getStats("n (%)"),
	dataTotal = dataTotalAE,
	labelVars = labelVars,
	title = "Table: Adverse Events by System Organ Class and Preferred Term",
	footer = c(
		"N=number of subjects with data; n=number of subjects with this observation",
		"Denominator for percentage calculations = the total number of subjects per treatment group in the safety population"
	),
	rowVarLab = c('AESOC' = "TEAE by SOC and Preferred Term\nn (%)"),
	style = "presentation",
	outputType = "data.frame-base"
)
pander(summaryTableAll, split.table = Inf)

```

### Differences between the format

Most of the functionalities and default parameters are the same
between the `flextable` and `DT` format, at the exception of:

* general layout: 
    + for the `DT` format, by default the variables and statistics are
    included in different columns: `rowVarInSepCol` is `rowVar` and `statsLayout` is set to 'col'
    + for the `flextable` format, by default the row variables and statistics are nested:
    `rowVarInSepCol` is set to: 'NULL' and the `statsLayout` is set to 'row'

## Export table to a separated file

The table can be exported to a separated file by specifying a file name in the **`file`** parameter. 

If the format is:

* _txt_: the raw base table is exported to a text file. This format can be used e.g. to QC with TLFs.
* _docx_: the formatted table is exported to a Word document. Such format is typically of interest to share the tables to the medical writers, to be imported directly into a SAP (if `style = 'report'`).
* _html_: an interactive table is exported to the specified html file

```{r file}

	# export table to a Word document
	summaryTableFt <- getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTA",
		stats = getStats("n (%)"),
		dataTotal = dataTotalAE,
		labelVars = labelVars,
		file = file.path("tables_CSR", "summaryTable-AEs.docx")
	)
	
	# export interactive table to a html document
	summaryTableFt <- getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTA",
		stats = getStats("n (%)"),
		dataTotal = dataTotalAE,
		labelVars = labelVars,
		file = file.path("tables_CSR", "summaryTable-AEs.html")
	)
	
	# export table in raw format to a text file
	summaryTableFt <- getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTA",
		stats = getStats("n (%)"),
		dataTotal = dataTotalAE,
		labelVars = labelVars,
		file = file.path("tables_CSR", "summaryTable-AEs.txt")
	)
	
	# export to multiple formats at once
	summaryTableFt <- getSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		colVar = "TRTA",
		stats = getStats("n (%)"),
		dataTotal = dataTotalAE,
		labelVars = labelVars,
		file = file.path("tables_CSR",
			c("summaryTable.txt", "summaryTable.docx", "summaryTable.html")
		)
	)

```

## Export table of pre-computed summary statistics

To create a table in similar format as the in-text tables created by the package,
from pre-computed summary statistics (e.g. from CRO or from a different software as _SAS_)
the function `exportSummaryStatisticsTable` is used.
This function takes as input a data.frame which should contain the 
summary statistics in a long format, in which the statistic value (`statsVar`);
statistic type (if multiple), grouping row and columns (`rowVar` and `colVar`)
are stored as different columns in the data.frame.

```{r exportSummaryStatisticsTable}

	dataPFEV1 <- subset(dataAll$ADRE, 
		FASFL == "Y" & PARAMCD == "FEV1PP" &
		(
			AVISIT == "Baseline" |
			# retain only: valid spirometry assessment (CRIT1)
			(AVISIT %in% c("Day 14", "Day 28", "Follow-up") & CRIT1FL == "Y")
			)
	)
	
	# create example of data.frame containing statistics of interest
	statsEff <- sapply(c("AVAL", "CHG"), function(var){
		getStats(
			type = c("n", "mean (se)", "median (range)"),
			x = dataPFEV1[[var]]
		)
	}, simplify = FALSE)
	summaryTable <- computeSummaryStatisticsTable(
		data = dataPFEV1,
		colVar = c("TRTP", "AVISIT"),
		var = c("AVAL", "CHG"), varGeneralLab = "",
		stats = statsEff,
		labelVars = labelVars
	)
	
	# format df with statistics to in-text tables format
	exportSummaryStatisticsTable(
		summaryTable = summaryTable,
		statsVar = c("Mean (SE)", "Median (range)"),
		rowVar = "variable", rowVarLab = "Statistic",
		colVar = c("TRTP", "AVISIT"),
		colHeaderTotalInclude = TRUE,
		labelVars = simpleCap(tolower(labelVars[c("AVAL", "CHG")])),
		title = toTitleCase("Table: Sweat chloride inferential statistics of the changes from baseline per time point (pharmacodynamics analysis Set, Mean Value from both arms)"),
		file = file.path("tables_CSR", "Table_SweatChlorideChangeFromBaseline_inferential.docx")
	)

```

If the column headers should contain total number of subjects, 
the corresponding counts should be stored in records with the column `isTotal` set to TRUE.

## Text formatting

Specific formatted text can be specified, for the `flextable`
output type only.

The pharmacokinetics data is used for demonstration.

```{r data-ADSL}
	
	dataPP <- subset(dataAll$ADPP, SAFFL == "Y")
	
	# ensure that order of elements is the one specified in the corresponding numeric variable
	library(glpgUtilityFct)
	dataPP <- convertVarToFactor(
		data = dataPP, 
		var = c("PARCAT1", "PARAM", "AVISIT", "TRTP"), 
		varNum = c("PARCAT1N", "PARAMN", "AVISITN", "TRTPN")
	)
	
```	

### Superscript/subscript

Superscript and superscript are specified via the special text pattern: `a^{b}` and subscript as `a_{b}` respectively.

To use a superscript or a subscript in the table, the text should be formatted as: `text^{superscript}` or `text_{subscript}`.

This is for example useful to reference additional informations in a specific footnote or specify custom variable labels.

```{r summaryTable-PP-rowVarWithLabel-rowVarLab-superscript}

	# format labels with subscript
	paramLabelPK <- c(
		CTROUGH = "C_{trough} (ng/mL)", 
		TLAG = "t_{lag} (h)",
		TMAX = 't_{max} (h)', 
		CMAX = "C_{max} (ng/mL)",
		AUCTAU = "AUC_{0-t} (ng.h/mL)",
		AUC08H = "AUC_{0-8h} (ng.h/mL)"
	)
	dataPP$PARAMRF <- paramLabelPK[dataPP$PARAMCD]
	
	getSummaryStatisticsTable(
		data = subset(dataPP, PARCAT1 %in% c("Ivacaftor", "Lumacaftor")),
		var = "AVAL",
		colVar = c("TRTP", "AVISIT"),
		rowVar = c("PARCAT1", "PARAMRF"),
		rowVarLab = c(
			'PARAMRF' = "Pharmacokinetics parameter\nfor each compound^{(1)}", # use superscript for the foonote
			'PARCAT1' = "" 
		),
		stats = list(expression(paste0(roundHalfUpTextFormat(statMean, 1), "\n(", roundHalfUpTextFormat(statSE, 2),")"))),
		# include the footnote
		footer = c(
			"(1) Each compound is labelled according to its Galapagos compound ID.",
			paste0("AUC_{0-t} represents the ", getLabelParamcd(paramcd = "AUCTAU", data = dataPP), ".")
		)
	)	

```

### Bold and greek letters

Specific cells of the table can be highlight in bold by using the syntax: `bold{}` in the `stats` or `statsExtra` function.

This highlighting may depend:

* on a additional variable via the `statsExtra` parameter:  
for example: `statsExtra <- function(data)   with(data, ifelse(ANRIND != "N", paste0("bold{", toString(AVAL), "}"), toString(AVAL))`
* on the values of computed statistics, via the `stats` parameter

Greek letter are included as it is in the table.

```{r summaryTable-PP-rowVarWithLabel-rowVarLab-bold}
	
	getSummaryStatisticsTable(
		data = subset(dataPP, PARCAT1 == "Lumacaftor"),
		var = "AVAL",
		colVar = c("TRTP", "AVISIT"),
		rowVar = "PARAMRF",
		rowVarLab = c(
			'PARAMRF' = "Pharmacokinetics parameter\nMean (SE*)", 
			'PARCAT1' = "Compound^{(1)}" # use superscript for the foonote
		),
		labelVars = labelVars,
		stats = list(
			expression(paste0(
				ifelse(statMean > statMedian, 
					paste0("bold{", roundHalfUpTextFormat(statMean, 1), "}"), 
					statMean
				), 
				"\n(", 
				roundHalfUpTextFormat(statSE, 2),")")
			)
		),
		# include greek letter
		footer = "*Standard error is computed as: SE = /n.",
		file = file.path("tables_CSR", "Table_textCustomization.docx")
	)	

```

## Create multiple tables by a variable

Multiple tables can be created for each element of a variable in the dataset
 by specifying this variable in `byVar`.  
 
 A list of final summary table can be included into a `rmarkdown` 
 document with the `knitPrintListObjects`. 

Please note that the following chunk option should be used: **`results = 'asis'`**.

For example, pharmacokinetic tables are created for each compound:

```{r byVar, results = "asis"}

	summaryTableList <- getSummaryStatisticsTable(
		data = subset(dataPP, PARCAT1 %in% c("Ivacaftor", "Lumacaftor")),
		var = "AVAL",
		colVar = c("TRTP", "AVISIT"),
		rowVar = "PARAMRF",
		rowVarLab = c(
			'PARAMRF' = "Pharmacokinetics parameter", 
			'PARCAT1' = "Compound^{(1)}" # use superscript for the foonote
		),
		byVar = "PARCAT1", 
		labelVars = labelVars,
		stats = list(expression(paste0(roundHalfUpTextFormat(statMean, 1), "\n(", roundHalfUpTextFormat(statSE, 2),")")))
	)	
	# print the list of tables in the rmarkdown document
	glpgUtilityFct::knitPrintListObjects(summaryTableList) 

```

## Filter records in a table

If only a subset of the records should be displayed in the final table, 
a custom filtering functions is specified via the `filterFct` parameter.

```{r countTable-AE-filterFct}

	library(plyr)
		
	# SOC with AE terms with at least 2 subjects
	getSummaryStatisticsTable(
		data = subset(dataAE, TRTEMFL == "Y"),
		rowVar = c("AESOC", "AEDECOD"),
		rowVarLab = c('AESOC' = "TEAE by SOC and Preferred Term\nn (%)"),
		colVar = "TRTP",
		stats = getStats("n (%)"),
		filterFct = function(x)
			ddply(x, "AESOC", function(y)
				if(any(y$statN >= 2))	y			
			),
		labelVars = labelVars,
		title = "Table: Adverse Events by System Organ Class and Preferred Term with at least 2 patients in System Organ Class"
	)
	
	# AE term with at least one term with more than 20% in the treatment
	getSummaryStatisticsTable(
		data = subset(dataAE, TRTEMFL == "Y"),
		rowVar = c("AESOC", "AEDECOD"),
		rowVarLab = c('AESOC' = "TEAE by SOC and Preferred Term\nn (%)"),
		colVar = "TRTP",
		stats = getStats("n (%)"),
		filterFct = function(x)
			ddply(x, "AEDECOD", function(xTerm){
				xTermTreatment <- subset(xTerm, grepl("75 mg", TRTP))
				if(xTermTreatment$statPercN >= 20)	xTerm		
			}),
		labelVars = labelVars,
		title = "Table: Adverse Events by System Organ Class and Preferred Term with at least 20% patients in treatment category"
	)
	
```

Note: to help for the creation of this filtering function, the displaying data could be extracted first via the `computeSummaryStatisticsTable` function (instead of creating directly the in-text table via the `getSummaryStatisticsTable`), then used to define the `filterFct` parameter.

```{r countTable-AE-filterFct- details}

	x <- computeSummaryStatisticsTable(
		data = subset(dataAE, TRTEMFL == "Y"),
		rowVar = c("AESOC", "AEDECOD"),
		rowVarLab = c('AESOC' = "TEAE by SOC and Preferred Term\nn (%)"),
		colVar = "TRTP",
		stats = getStats("n (%)"),
		labelVars = labelVars
	)
	head(x)
	# for specific AEDECOD
	xTerm <- subset(x, AEDECOD == "Viral upper respiratory tract infection")
	# identify the record for treated patient:
	subset(xTerm, grepl("75 mg", TRTP))
	# keep all records (placebo + treatment) if percentage if higher than 20%:
	# if no 'else' condition, nothing (NULL) is returned:
	if(subset(xTerm, grepl("75 mg", TRTP))$statPercN >= 20)	xTerm
	# across all AE terms:
	ddply(x, "AEDECOD", function(xTerm)
		if(subset(xTerm, grepl("75 mg", TRTP))$statPercN >= 20)	xTerm
	)
	# format it as a function and pass it to the 'filterFct' parameter
```

# Detailed framework of the creation of the in-text table

The `getSummaryStatisticsTable` consists of the following framework:

* computation of the summary statistics table with the `computeSummaryStatisticsTable` function
* export of the table to the required format (`outputType` parameter)

## Computation of the summary statistics

The supporting data for the summary statistics table, including the entire set of statistics (as numeric) and combined statistic set is accessed via the `computeSummaryStatisticsTable`.

This is equivalent of the table output by the `getSummaryStatisticsTable` function, with the `outputType` set to 'data.frame-base'.

```{r computeSummaryStatisticsTable}

	summaryTable <- computeSummaryStatisticsTable(
		data = dataAEInterest,
		rowVar = c("AESOC", "AEDECOD"),
		rowVarTotalInclude = c("AESOC", "AEDECOD"),
		colVar = "TRTA",
		stats = getStats("n (%)"),
		dataTotal = dataTotalAE,
		labelVars = labelVars,
		rowVarLab = c('AESOC' = "TEAE by SOC and Preferred Term\nn (%)")
	)
	pander(summaryTable)
	
```	

Please note the presence of the `isTotal` column, which flags the records containing the number of subjects reported in the table header.

```{r computeSummaryStatisticsTable-isTotal}

	pander(subset(summaryTable, isTotal))
	
```	

## Export table to the requested format

The table is exported with the requested format (by default `flextable`) with the function `exportSummaryStatisticsTable`:

* `flextable` format:
```{r exportSummaryStatisticsTable-flextable}

	exportSummaryStatisticsTable(summaryTable = summaryTable)
	
```	
* `DT` format:
```{r exportSummaryStatisticsTable-DT}

	exportSummaryStatisticsTable(summaryTable = summaryTable, outputType = "DT")
	
```	
* `data.frame` output
```{r exportSummaryStatisticsTable-data.frame}

	pander(
		exportSummaryStatisticsTable(summaryTable = summaryTable, outputType = "data.frame")
	)
	
```	


# Data pre-processing

The variables used for the row and columns of the summary statistics tables
should be present in a long format in the input data for
the `getSummaryStatisticsTable` function.

In case the grouping of the rows/columns is more complex and no
grouping variable is yet available in the data,
the function `combineVariables` offers simpler functionalities to
create the input data.

The label for the grouping is extracted from the SAS dataset labels if
`labelVars` is specified, or can be customized (`label` parameter).

For example, the adverse events are counted for different population set:
screened population, completer population, only events with high severity,
or related to the treatment and with high severity.

```{r combineVariables}

	# prepare the data: create grouping of interest
	dataAEGroup <- combineVariables(
		data = dataAEInterest,
		newVar = "AEGRP",
		paramsList = list(
			# for all screened patients
			list(var = "SCRNFL", value = "Y"),
			# only for completers patients
			list(var = "COMPLFL", value = "Y"),
			# for high severity
			list(var = "AESEVN", value = 2, fctTest = ">=", labelExtra = "higher than 2"),
			# related and with higher severity
			list(
				exprs = 'AREL == "Related" & AESEVN >= 2',
				label = paste(
					labelVars["AREL"], 
					"with", labelVars["AESEV"], "higher than 2"
				)
			),
			list(var = "AENDY", label = paste("With adverse events ending date"))
		),
		# include also counts for all records
		includeAll = TRUE, labelAll = "All Adverse events", 
		labelVars = labelVars
	)
	labelVars["AEGRP"] <- "Patient groups of interest"
	
	# create the table
	getSummaryStatisticsTable(
		data = dataAEGroup,
		colVar = "TRTA", 
		rowVar = "AEGRP", 
		labelVars = labelVars,
		dataTotal = dataTotalAE,
		stats = list(expression(paste0(statN, " (", round(statPercN, 1), ")"))),
		title = "Table: Adverse events: counts for groups of interest",
		footer = "Statistics: n (%)"
	)

```

# Visualization

Summary statistics can be visualized via **error bars** by:

* extracting the summary statistics table with the
  `computeSummaryStatisticsTable` function (used for `getSummaryStatistics` function)
* visualizing the summary statistics via the `subjectProfileSummaryPlot`
  function
  
```{r visualization-extractData}

	summaryTableDf <- computeSummaryStatisticsTable(
		data = dataPP,
		var = "AVAL",
		rowVar = c("PARCAT1", "PARAM"),
		colVar = c("TRTP", "AVISIT")
	)

```

## With table

```{r visualization-table}

	# create the plot
	subjectProfileSummaryPlot(
		data = subset(summaryTableDf, !isTotal & 
			PARCAT1 == "Ivacaftor" & grepl("Ctrough", PARAM)
		),
		xVar = "AVISIT",
		colorVar = "TRTP",
		labelVars = labelVars,
		useLinetype = TRUE,
		tableText = "statN"
	)

```

## By facets

```{r visualization-facets, out.width = "100%", fig.height = 15, fig.width = 15}

	# create the plot
	subjectProfileSummaryPlot(
		data = subset(summaryTableDf, !isTotal),
		xVar = "AVISIT",
		colorVar = "TRTP",
		labelVars = labelVars,
		facetVar = c("PARCAT1", "PARAM"),
		useLinetype = TRUE
	)

```

# Appendix

## Session information

```{r includeSessionInfo, echo = FALSE}

	pander(sessionInfo())

```
